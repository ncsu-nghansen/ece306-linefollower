###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.60.5.50814/W32 for MSP430       15/Apr/2014  15:17:05 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Users\Nathan\Documents\GitHub\ece306-linefollower\ad #
#                     c.c                                                     #
#    Command line  =  C:\Users\Nathan\Documents\GitHub\ece306-linefollower\ad #
#                     c.c -lC C:\Users\Nathan\Documents\GitHub\ece306-linefol #
#                     lower\Debug\List\ -o C:\Users\Nathan\Documents\GitHub\e #
#                     ce306-linefollower\Debug\Obj\ --no_cse --no_unroll      #
#                     --no_inline --no_code_motion --no_tbaa --debug          #
#                     -D__MSP430FR5739__ -e --double=32 --dlib_config         #
#                     "C:\Program Files (x86)\IAR Systems\Embedded Workbench  #
#                     6.5\430\LIB\DLIB\dl430xsfn.h" --core=430X               #
#                     --data_model=small -Ol --multiplier=32                  #
#                     --multiplier_location=4C0 --hw_workaround=CPU40         #
#    List file     =  C:\Users\Nathan\Documents\GitHub\ece306-linefollower\De #
#                     bug\List\adc.lst                                        #
#    Object file   =  C:\Users\Nathan\Documents\GitHub\ece306-linefollower\De #
#                     bug\Obj\adc.r43                                         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Nathan\Documents\GitHub\ece306-linefollower\adc.c
      1          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x700
   \   union <unnamed> _A_ADC10CTL0_L
   \                     _A_ADC10CTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x702
   \   union <unnamed> _A_ADC10CTL1_L
   \                     _A_ADC10CTL1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x70a
   \   union <unnamed> _A_ADC10MCTL0_L
   \                     _A_ADC10MCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x712
   \   union <unnamed> _A_ADC10MEM0_L
   \                     _A_ADC10MEM0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x71e
   \   union <unnamed> _A_ADC10IV_L
   \                     _A_ADC10IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x202
   \   union <unnamed> _A_PAOUT_L
   \                     _A_PAOUT_L:
   \   000000                DS8 2
      2          #include  "functions.h"
      3          #include  "macros.h"
      4          

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
      5          volatile int ADC_Thumb = 255;
   \                     ADC_Thumb:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for ADC_Thumb>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      6          volatile int ADC_LeftIR = 0; 
   \                     ADC_LeftIR:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      7          volatile int ADC_RightIR = 0;
   \                     ADC_RightIR:
   \   000000                DS8 2
      8          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      9          volatile int LeftLight = 0;
   \                     LeftLight:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     10          volatile int LeftDark = 0;
   \                     LeftDark:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     11          volatile int RightLight = 0;
   \                     RightLight:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     12          volatile int RightDark = 0;
   \                     RightDark:
   \   000000                DS8 2
     13          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     14          volatile int leftThreshold;
   \                     leftThreshold:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     15          volatile int rightThreshold;
   \                     rightThreshold:
   \   000000                DS8 2
     16          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     17          int AdcChannel = ADC10INCH_0;
   \                     AdcChannel:
   \   000000                DS8 2
     18          
     19          /** 
     20          * ADC10 interrupt service routine
     21          * ADC_Right_Detector; // A00 ADC10INCH_0 - P1.0
     22          * ADC_Left_Detector; // A01 ADC10INCH_1 - P1.1
     23          * ADC_Thumb; // A03 ADC10INCH_3 - P1.3
     24          * ADC_Temp; // A10 ADC10INCH_10 – Temperature REF module
     25          * ADC_Bat; // A11 ADC10INCH_11 - Internal
     26          **/
     27          #pragma vector=ADC10_VECTOR

   \                                 In  segment ISR_CODE, align 2
     28          __interrupt void ADC10_ISR(void)
   \                     ADC10_ISR:
     29          {
   \   000000   0F12         PUSH.W  R15
     30          	switch(__even_in_range(ADC10IV,12)) 
   \   000002   1F421E07     MOV.W   &0x71e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for ADC10_ISR>_0`:
   \   000008   2C3C         JMP     ??ADC10_ISR_1
   \   00000A   2B3C         JMP     ??ADC10_ISR_1
   \   00000C   2A3C         JMP     ??ADC10_ISR_1
   \   00000E   293C         JMP     ??ADC10_ISR_1
   \   000010   283C         JMP     ??ADC10_ISR_1
   \   000012   273C         JMP     ??ADC10_ISR_1
   \   000014   003C         JMP     ??ADC10_ISR_5
     31          	{
     32          		case 0: break; // No interrupt
     33          		case 2: break; // conversion result overflow
     34          		case 4: break; // conversion time overflow
     35          		case 6: break; // ADC10HI
     36          		case 8: break; // ADC10LO
     37          		case 10: break; // ADC10IN
     38          		case 12:
     39                            
     40                                  ADC10CTL0 &= ~ADC10ENC;
   \                     ??ADC10_ISR_5:
   \   000016   A2C30007     BIC.W   #0x2, &0x700
     41          				
     42          			switch(AdcChannel)//Put an incrementing break statement to update different channels in turn
   \   00001A   1F42....     MOV.W   &AdcChannel, R15
   \   00001E   0F83         SUB.W   #0x0, R15
   \   000020   0524         JEQ     ??ADC10_ISR_2
   \   000022   1F83         SUB.W   #0x1, R15
   \   000024   0B24         JEQ     ??ADC10_ISR_3
   \   000026   1F83         SUB.W   #0x1, R15
   \   000028   1224         JEQ     ??ADC10_ISR_4
   \   00002A   183C         JMP     ??ADC10_ISR_0
     43          			{
     44          				case 0: 
     45          					ADC_LeftIR = ADC10MEM0;
   \                     ??ADC10_ISR_2:
   \   00002C   92421207.... MOV.W   &0x712, &ADC_LeftIR
     46          					ADC10MCTL0 = ADC10INCH_1;
   \   000032   92430A07     MOV.W   #0x1, &0x70a
     47          					AdcChannel = 1;
   \   000036   9243....     MOV.W   #0x1, &AdcChannel
     48          					break;
   \   00003A   103C         JMP     ??ADC10_ISR_0
     49          				case 1:
     50          					ADC_RightIR = ADC10MEM0;
   \                     ??ADC10_ISR_3:
   \   00003C   92421207.... MOV.W   &0x712, &ADC_RightIR
     51          					ADC10MCTL0 = ADC10INCH_3;
   \   000042   B24003000A07 MOV.W   #0x3, &0x70a
     52          					AdcChannel = 2;
   \   000048   A243....     MOV.W   #0x2, &AdcChannel
     53          					break;
   \   00004C   073C         JMP     ??ADC10_ISR_0
     54          				case 2:
     55          					ADC_Thumb = ADC10MEM0; 
   \                     ??ADC10_ISR_4:
   \   00004E   92421207.... MOV.W   &0x712, &ADC_Thumb
     56          					ADC10MCTL0 = ADC10INCH_0;
   \   000054   82430A07     MOV.W   #0x0, &0x70a
     57          					AdcChannel = 0;
   \   000058   8243....     MOV.W   #0x0, &AdcChannel
     58          					break;
     59          				default:
     60          					break;
     61          			}
     62                                  
     63                                  ADC10CTL0 |= ADC10ENC | ADC10SC;
   \                     ??ADC10_ISR_0:
   \   00005C   B2D003000007 BIS.W   #0x3, &0x700
     64                                  break;
     65                                  
     66          		default: 
     67          			break;
     68          	}
     69          }
   \                     ??ADC10_ISR_1:
   \   000062   3F41         POP.W   R15
   \   000064   0013         RETI
   \   000066                REQUIRE _A_ADC10CTL0_L
   \   000066                REQUIRE _A_ADC10MEM0_L
   \   000066                REQUIRE _A_ADC10MCTL0_L
   \   000066                REQUIRE _A_ADC10IV_L
     70          

   \                                 In  segment CODE, align 2
     71          void ADC_Process(void)
   \                     ADC_Process:
     72          {
     73          	P1OUT |= IR_LED;
   \   000000   E2D20202     BIS.B   #0x4, &0x202
     74                  
     75          	while (ADC10CTL1 & BUSY); // Wait if ADC10 core is active
   \                     ??ADC_Process_0:
   \   000004   92B30207     BIT.W   #0x1, &0x702
   \   000008   FD2F         JC      ??ADC_Process_0
     76          	ADC10CTL0 |= ADC10ENC | ADC10SC; // Sampling and conversion start
   \   00000A   B2D003000007 BIS.W   #0x3, &0x700
     77          }
   \   000010   1001         RETA
   \   000012                REQUIRE _A_PAOUT_L
   \   000012                REQUIRE _A_ADC10CTL1_L
   \   000012                REQUIRE _A_ADC10CTL0_L
     78          

   \                                 In  segment CODE, align 2
     79          void CalibrateIR(void)
   \                     CalibrateIR:
     80          {
     81          	leftThreshold = (LeftDark + LeftLight)/2;
                 	^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   000000   1C42....     MOV.W   &LeftDark, R12
   \   000004   1C52....     ADD.W   &LeftLight, R12
   \   000008   2E43         MOV.W   #0x2, R14
   \   00000A   ........     CALLA   #?DivMod16s
   \   00000E   824C....     MOV.W   R12, &leftThreshold
     82          	rightThreshold = (RightDark + RightLight)/2;
                 	^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   000012   1C42....     MOV.W   &RightDark, R12
   \   000016   1C52....     ADD.W   &RightLight, R12
   \   00001A   2E43         MOV.W   #0x2, R14
   \   00001C   ........     CALLA   #?DivMod16s
   \   000020   824C....     MOV.W   R12, &rightThreshold
     83          }
   \   000024   1001         RETA
     84          

   \                                 In  segment CODE, align 2
     85          char IsRightIrLight()
   \                     IsRightIrLight:
     86          {
     87          	return (ADC_RightIR < rightThreshold);
                 	^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   000000   9292........ CMP.W   &rightThreshold, &ADC_RightIR
   \   000006   0234         JGE     ??IsRightIrLight_0
   \   000008   5C43         MOV.B   #0x1, R12
   \   00000A   1001         RETA
   \                     ??IsRightIrLight_0:
   \   00000C   4C43         MOV.B   #0x0, R12
   \   00000E   1001         RETA
     88          }
     89          

   \                                 In  segment CODE, align 2
     90          char IsLeftIrLight()
   \                     IsLeftIrLight:
     91          {
     92          	return (ADC_LeftIR < leftThreshold);
                 	^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   000000   9292........ CMP.W   &leftThreshold, &ADC_LeftIR
   \   000006   0234         JGE     ??IsLeftIrLight_0
   \   000008   5C43         MOV.B   #0x1, R12
   \   00000A   1001         RETA
   \                     ??IsLeftIrLight_0:
   \   00000C   4C43         MOV.B   #0x0, R12
   \   00000E   1001         RETA
     93          }

   \                                 In  segment INTVEC, offset 0x5c, root
   \                     `??ADC10_ISR??INTVEC 92`:
   \   00005C   ....         DC16    ADC10_ISR

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for ADC_Thumb>`:
   \   000000   FF00         DC16 255

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      6   ADC10_ISR
      4   ADC_Process
      4   CalibrateIR
      4   IsLeftIrLight
      4   IsRightIrLight


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Initializer for ADC_Thumb>
       2  ??ADC10_ISR??INTVEC 92
     102  ADC10_ISR
       2  ADC_LeftIR
      18  ADC_Process
       2  ADC_RightIR
       2  ADC_Thumb
       2  AdcChannel
      38  CalibrateIR
      16  IsLeftIrLight
      16  IsRightIrLight
       2  LeftDark
       2  LeftLight
       2  RightDark
       2  RightLight
       2  _A_ADC10CTL0_L
       2  _A_ADC10CTL1_L
       2  _A_ADC10IV_L
       2  _A_ADC10MCTL0_L
       2  _A_ADC10MEM0_L
       2  _A_PAOUT_L
       2  leftThreshold
       2  rightThreshold

 
  88 bytes in segment CODE
  12 bytes in segment DATA16_AN
   2 bytes in segment DATA16_I
   2 bytes in segment DATA16_ID
  18 bytes in segment DATA16_Z
   2 bytes in segment INTVEC
 102 bytes in segment ISR_CODE
 
 190 bytes of CODE  memory
   2 bytes of CONST memory (+  2 bytes shared)
  20 bytes of DATA  memory (+ 12 bytes shared)

Errors: none
Warnings: 4
